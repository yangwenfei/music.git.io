#安装#

    npm install webpack webpack-cli --save-dev

#package.json#

"script":{//执行操作的入口文件
"build":"webpack"
}
注：执行 webpack 命令会生成打包文件

#加载 css#

css-loader 和 style-loader //use 数组中 style-loader 和 css-loader 顺序不能换，否则会报错
rules:[
...
{
'test': /\.css\$/,
'use':['style-loader','css-loader']
}
]

#加载图片#
file-loader 或者是 url-loader 进行图片处理(两者的区别也是性能优化的一个点，使用 url-loader)
rules:[
...
{
'test':/\.(png|jpg|gif|svg|ico)\$/,
'use':['file-loader']
}
]
注：file-loader 在打包的时候会在 dist 中拷贝一份，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。

url-loader
rules:[
...
{
'test': /\.(png|gif|jpg|svg|ico)\$/,
'loader': 'url-loader',
'options': {
'limit': 10000,
'name': '[path][name][hash:7].[ext]' //自定义设置输出文件的文件名规则、发布路径
'outputPath':'img/'
//name 与 outpuPath 可以简写成一条：name:'img/[path][name][hash:7].[ext]'
}
}
]
注：url-loader 在打包的时候会把小于 limit 字节的图片转成 dataURL，不会拷贝。大于 limit 限制的图片才会进行 file-loader 相关的操作
name 表示输出的文件名规则，如果不添加这个参数，输出的就是默认值：文件哈希。加上[path]表示输出文件的相对路径与当前文件相对路径相同，加上[name].[ext]则表示输出文件的名字和扩展名与当前相同。加上[path]这个参数后，打包后文件中引用文件的路径也会加上这个相对路径。

outputPath 表示输出文件路径前缀。图片经过 url-loader 打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。比如 outputPath=img/，图片被打包时，就会在输出文件夹下新建（如果没有）一个名为 img 的文件夹，把图片放到里面。

file-loader 和 url-loader 对处理图片的区别：以图片为例，file-loader 可对图片进行压缩，但是还是通过文件路径进行引入，当 http 请求增多时会降低页面性能，而 url-loader 通过设定 limit 参数，小于 limit 字节的图片会被转成 base64 的文件，大于 limit 字节的将进行图片压缩的操作。总而言之，url-loader 是 file-loader 的上层封装。
https://blog.csdn.net/qq_38652603/article/details/73835153（链接进行详解）

#加载字体#
file-loader 或者 url-loader (同理于加载图片)

#HtmlWebpackPlugin#
会生成一个 html5 文件，并将打包后的所有 js 自动添加到 html 中。
html-webpack-plugin

#清理 /dist 文件#
在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件。让我们完成这个需求。
clean-webpack-plugin

注:通过 htmlWebpackPlugin 和 clean-webpack-plugin 就可以每次打包的时候自动的生成 dist 文件下面的 html 文件及刷新整个 dist

#开发环境的相关配置#
一、 source map
当 webpack 打包源代码后，就很难追踪到错误和警告在源代码中的原位置。js 提供的 source map 功能，将编译后的代码映射回源代码，如果一个错误来源于 b.js,通过 source map 的配置就可以明确的定位到
https://webpack.docschina.org/configuration/devtool(链接)，devtool有很多参数可选，用于生产环境和开发环境的参数值不一样，并且与打包构建的速度也有关。
devtool:'inline-source-map' ;

二、webpack-dev-service
当代码发生修改和变化时自动编译代码，不用每次修改都手动的运行一次 npm run dev
webpack-dev-service 是一个简单的 web 服务器，并且能够实时重新加载.vue 项目在本地启动的服务器就是通过启动 dev-server，在 localhost:8080 下建立服务，
npm install --save-dev webpack-dev-server

devServer: {
contentBase:'./dist'
},
以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。

启动 devServer 服务，在 package.json 中配置启动命令
script:{
'start':'webpack-dev-server --open'
}
我们可以在命令行中运行 npm start，就会看到浏览器自动加载页面。如果现在修改和保存任意源文件，web 服务器就会自动重新加载编译后的代码。

注：当配置了 devServer ，启动命令变成了 webpack-dev-server 后，打包后的文件 dist 就没有，需要重新配置可以生成 dist 打包文件的命令

三、模块热替换（HMR）

devServer:{
...
hot:true
}
pugins:[
...
new webpack.NamedModulesPlugin(),//为了更快的将变化的内容进行替换修改
new webpack.HotModuleReplacementPlugin()
]

#生产环境构建#
构建生产环境前需要将开发环境与生产环境的配置要分离开，公共的部分要单独提取出来。需要使用 webpack-merge

npm install webpack-merge --save-dev

配置文件的结构目录

- webpack.common.js
- webpack.dev.js
- webpack.prod.js

#代码分离#

代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间

三种常用的代码分离方法：
(1)入口起点：使用 entry 配置手动地分离代码

(2)防止重复：使用 CommonsChunkPlugin 去重和分离 chunk
plugins:[
...
//webpack.optimize.CommonsChunkPlugin 这种写法在 4.0 已经废弃，
new webpack.optimize.SplitChunksPlugin({
chunks: "initial",
minSize: 3, // 模块的最小体积
minChunks: 1, // 模块的最小被引用次数
maxAsyncRequests: 5, // 按需加载的最大并行请求数
maxInitialRequests: 3, // 一个入口最大并行请求数
automaticNameDelimiter: '-', // 文件名的连接符
name: true,
cacheGroups: { // 缓存组
vendors: { //将 node_modules 中引用的模块打包到一个 js 中
name: 'vendors',
test: /[\\/]node_modules[\\/]/,
priority: 0
},
default: { // 模块之间引用的公共模块被打包到一个公共的 js 中
name: 'common',
minChunks: 2,
priority: 0,
reuseExistingChunk: true
}
}

    })

]
(3)动态导入：通过模块的内联函数调用来分离代码

### css 单独分离 ExtractTextWebpackPlugin 插件

安装 npm install extract-text-webpack-plugin@next --save-dev

使用
const ExtractTextPlugin = require("extract-text-webpack-plugin");
module.exports = {
module: {
rules: [
{
test: /\.css$/,
use: ExtractTextPlugin.extract({
fallback: "style-loader",
use: "css-loader"
})
}
]
},
plugins: [
new ExtractTextPlugin("styles.css"),
]
}

##gitignore 文件

1、在需要创建 .gitignore 文件的文件夹, 右键选择 Git Bash 进入命令行，进入项目所在目录。

2、输入 touch .gitignore ，生成“.gitignore”文件。
3、在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式）

我的 .gitignore：

.deploy_git/
node_modules/
